---
title: "Analisis de composición taxonomica"
output: html_notebook
---

# Introduccion

Hasta este momento hemos estado contando CUANTO hay dentro de nuestras muestras pero lo verdaderamente util es saber QUE hay dentro de las muestras. Esto es a lo que se le llama _analisis taxonomico._

__Porque es importante?__

Como les comentaba las comunidades microbianas en suelos son muy dinamicas y muchas veces (como con mis datos) no ves cambios en las cantidades totales de microorganismos. Sin embargo, al ver la taxonomia las abundancias relativas de algunos grupos pueden ser modificados ya sea aumentado o disminuido. 

De esta manera se espera que cualquier producto o tratamiento que apliquemos al suelo, no tenga un efecto detrimental en grupos taxonomicos que son buenos para la planta. Dado que todas estos hongos y microbios interactuan constantemente en este microecosistema estos cambios en abundancia pueden darnos pista de como interactuan.

```{r}

## Librarías ##

library(phyloseq)
library(tidyverse)
library(dplyr)
library(RColorBrewer)
library(pheatmap) # Heatmaps
library(microbiome)
library(ggsignif)
library(scales) # Modificar escalas
library(car)
library(wesanderson)

# DATA 

load("ITS_filt.Rdata") # analisis estadistico 
load("Vid_ejemplos.RData")

```

Este analisis no cumple con un proceso en específico y en realidad es exploratorio. Para ello necesitamos visualizar nuestros datos, o sea, hacer variedad de gráficos y de ahí se elige a cuales grupos vale la pena hacer análisis taxonómico 

# 1. Visualizar a nivel de Phylum

## Heatmap

```{r}

Phyla_fun <- tax_glom(vid_bio, taxrank = "Phylum", NArm = FALSE)

## Extraer datos del objeto phyloseq

OTU_matrix <- as.data.frame(Phyla_fun@otu_table)
Tax_matrix <- as.data.frame(Phyla_fun@tax_table)

# Renombramos las columnas de nuestras abundancias con el phylum de la tabla taxa

colnames(OTU_matrix) <- Tax_matrix$Phylum 

# Quitar phylum desconocido (SOLO DATOS DE VID)

OTU_matrix <- OTU_matrix[, -c(10,21)] #aqui paso algo con la tabla por lo cual aparecian en NA y asi no nos sirven por lo cual quitamos esas columans que nos estorban ya que no se puede

# Crear matriz (afuerzas tenemos que trabajar con matrices, opor eso creamos la matriz a partir de los OTUs)
Phyla_matrix <- as.matrix(t(OTU_matrix))

```

# Procesamiento de datos 

Este proceso es específico para cada set de datos. Usualmente los heatmaps siempre van de mayor a menor, así que ese paso siempre se realiza, pero el resto consta de de ordenar las muestras y renombrar variables.

```{r}

Phyla_matrix <- Phyla_matrix[order(Phyla_matrix[,1], #ese 1 corresponde a la primera columna y eso nos da en el codigo que todas las columnas se van a cambiar de mayor a menos 
                                   decreasing = TRUE),] # Ordenar de mayor a menor 

# Cambiar el orden de las muestras

sorder <- c("S81", "S85", "S82", "S83") # acomodamos asi para tener bioestimulante y bioestumulanta y luego control y control

Phyla_matrix <- Phyla_matrix[,sorder] # con esta funcion unimos los valores 

row.names(Phyla_matrix)[16] <- "SAR324 Clade" # Con este le cambiamos el nombre a una fila que tenía un nombre muy largo, osea recortamos el nombre 


```

## Usando el paquete Pheatmap para realizar heatmaps de análisis taxonómico 


```{r}
pheatmap(Phyla_matrix) # El objeto siempre debe de estar en formato de matriz y los valores como numéricos... en este salen clouster osea las lineas que ordenan entre grupos por asi decirlo
```

### _Notan algo en el orden de nuestras filas y columnas? Clusters_
La funcion default de pheatmap es que automaticamente te reacomoda (cluster) tus filas y columnas de acuerdo a como cree que estan mas relacionadas las variables; es decir las agrupa. Esta funcion suele ser util cuando haces heatmaps de genes ya que te permite ver como se activan o apagan en conjunto y si hay "clusters" de genes relacionados. Pero en nuestro caso arruino todo el pre-procesamiento previo que nosotros le dimos por lo que tenemos que quitarle ese default.

```{r}
pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE) # quitar clusters
```

### El siguiente problema? La escala 

Si se fijan los colores en este heatmap son cero utiles. Solo tenemos cambios graduales en una columna y el resto se ven todas horribles. Esto ocurre porque nuestros datos tienen mucha variacion entre ellos por lo que se puede arreglar de varias maneras y la funcion de pheatmap tiene el argumento de scala para tratar de solucionarlo. El default siempre es _none_ pero tambien se puede modificarlo por filas y columnas: 

```{r}
pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "none") # default

pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "column") # trasforma los valores usando de escala las muestras...osea las columnas...ESTE CASI NO LO VAMOS A USAR   

pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "row") # transforma los valor4es usando de escla los phylums...osea las filas... esta grafica esta bien solo se deberia cambiar la leyeda de la escala
```

Cual creen que es mas util? 

Desafortunadamente ninguno de ellos es muy util. El de columnas no hizo nada porque el problema recae en que tenemos phylums con muuucha abundancia y otros que casi estan llenos de ceros mientras; pero eso pasa en todas las muestras por lo que al tratar de escalarlo se ve asi. 

En el caso de la transformacion por filas nos va un poco mejor porque trata de normalizar las abundancias de todos los phylums a una escala. Sin embargo, por el mismo problema anterior lo unico que nos resalta es si alguna de las muestras tiene numeros extranamente altos o bajos DENTRO de ese mismo phylum. Es decir nos compara dentro de phylums pero no entre ellos. Asi que les voy a compartir el codigo que me tomo literalmente 1 semana encontrar y basicamente salvo mi tesis.

### _Como modificar la escala manualmente? breaks_

```{r}
## Funcion especificamente para separar nuestros datos en secciones 

quantile_breaks <- function(xs, n = 10) {
  breaks <- quantile(xs, probs = seq(0, 1, length.out = n))
  breaks[!duplicated(breaks)]
} # recordar que la funcion NUNCA se cambia de nombre (osea copiar y pegar siempre entre documentos igual)


mat_breaks <- quantile_breaks(Phyla_matrix, #la matriz
                              n = 10) # el default es 10 pero se puede poenr4 el numero de cortes que quiero en mis datos 
mat_breaks


pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "none", # regresamos a que nos ponga escala 
         breaks = mat_breaks) # aqui ponemos el objeto con cortes que creamos
```

### Por que no se ve bien los colores?

Aunque ya puede ver una mejora en nuestra escala el problema ahora es que la funcion no tiene la cantidad adecuada de colores para representar nuestros datos. Por ello nosotros le vamos a dar otros colores: 

```{r}
pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "none", # regresamos a que nos ponga escala 
         breaks = mat_breaks,
         color = colorRampPalette(c("snow2", "#B23AEE", "maroon1", "violetred4"))(9)) # este numero debe de ser mas pequeño que n de la funcion osea el n del met_break....el numero de de colores debe ser minimo 4 y es a como queremos nosotros osea donde se vea mas diferenciado 
```

### Mini ejercicio 

Cada quien va a poner un numero diferente en los breaks para que vean como cambiar el grafico. Recuerden a mas breaks mayor diferencias o cambios de color: 

```{r}
mat_breaks <- quantile_breaks(Phyla_matrix, #la matriz
                              n = 25) # el default es 10 pero se puede poenr4 el numero de cortes que quiero en mis datos 
mat_breaks


pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "none", # regresamos a que nos ponga escala 
         breaks = mat_breaks,
         color = colorRampPalette(c("snow2", "#00F5FF", "dodgerblue4", "#030303"))(21)) # este numero debe de ser mas pequeño que n de la funcion 



pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "none", # regresamos a que nos ponga escala 
         breaks = mat_breaks,
         color = colorRampPalette(c("snow2","lightskyblue1","plum3","magenta4","steelblue4","black"))(21)) # estos son los colores de la tesis de Isabel

# como conclusion es modificar los mat_breaks y luego el pheatmap
```

### _Los ultimos elementos de formato_

```{r}
# a partir de aqui va a ser diferente entre cada pheatmap
pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "none", # regresamos a que nos ponga escala
         color = colorRampPalette(c("snow2", "#00F5FF", "dodgerblue4", "#030303"))(21),
         breaks = mat_breaks,
         fontsize = 8, # tamaño de letra 
         gaps_col = c(2), #separacion entre columnas
         labels_col = c("Balox Salino", "Balox No Salino","Control Salino",
                        "Control No Salino"))
```

