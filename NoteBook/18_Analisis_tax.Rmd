---
title: "Analisis de composición taxonomica"
output: html_notebook
---

# Introduccion

Hasta este momento hemos estado contando CUANTO hay dentro de nuestras muestras pero lo verdaderamente util es saber QUE hay dentro de las muestras. Esto es a lo que se le llama _analisis taxonomico._

__Porque es importante?__

Como les comentaba las comunidades microbianas en suelos son muy dinamicas y muchas veces (como con mis datos) no ves cambios en las cantidades totales de microorganismos. Sin embargo, al ver la taxonomia las abundancias relativas de algunos grupos pueden ser modificados ya sea aumentado o disminuido. 

De esta manera se espera que cualquier producto o tratamiento que apliquemos al suelo, no tenga un efecto detrimental en grupos taxonomicos que son buenos para la planta. Dado que todas estos hongos y microbios interactuan constantemente en este microecosistema estos cambios en abundancia pueden darnos pista de como interactuan.

```{r}

## Librarías ##

library(phyloseq)
library(tidyverse)
library(dplyr)
library(RColorBrewer)
library(pheatmap) # Heatmaps
library(microbiome)
library(ggsignif)
library(scales) # Modificar escalas
library(car)
library(wesanderson)

# DATA 

load("ITS_filt.Rdata") # analisis estadistico 
load("Vid_ejemplos.RData")

```

Este analisis no cumple con un proceso en específico y en realidad es exploratorio. Para ello necesitamos visualizar nuestros datos, o sea, hacer variedad de gráficos y de ahí se elige a cuales grupos vale la pena hacer análisis taxonómico 

# 1. Visualizar a nivel de Phylum

## Heatmap

```{r}

Phyla_fun <- tax_glom(vid_bio, taxrank = "Phylum", NArm = FALSE)

## Extraer datos del objeto phyloseq

OTU_matrix <- as.data.frame(Phyla_fun@otu_table)
Tax_matrix <- as.data.frame(Phyla_fun@tax_table)

# Renombramos las columnas de nuestras abundancias con el phylum de la tabla taxa

colnames(OTU_matrix) <- Tax_matrix$Phylum 

# Quitar phylum desconocido (SOLO DATOS DE VID)

OTU_matrix <- OTU_matrix[, -c(10,21)] #aqui paso algo con la tabla por lo cual aparecian en NA y asi no nos sirven por lo cual quitamos esas columans que nos estorban ya que no se puede

# Crear matriz (afuerzas tenemos que trabajar con matrices, opor eso creamos la matriz a partir de los OTUs)
Phyla_matrix <- as.matrix(t(OTU_matrix))

```

# Procesamiento de datos 

Este proceso es específico para cada set de datos. Usualmente los heatmaps siempre van de mayor a menor, así que ese paso siempre se realiza, pero el resto consta de de ordenar las muestras y renombrar variables.

```{r}

Phyla_matrix <- Phyla_matrix[order(Phyla_matrix[,1], #ese 1 corresponde a la primera columna y eso nos da en el codigo que todas las columnas se van a cambiar de mayor a menos 
                                   decreasing = TRUE),] # Ordenar de mayor a menor 

# Cambiar el orden de las muestras

sorder <- c("S81", "S85", "S82", "S83") # acomodamos asi para tener bioestimulante y bioestumulanta y luego control y control

Phyla_matrix <- Phyla_matrix[,sorder] # con esta funcion unimos los valores 

row.names(Phyla_matrix)[16] <- "SAR324 Clade" # Con este le cambiamos el nombre a una fila que tenía un nombre muy largo, osea recortamos el nombre 


```

## Usando el paquete Pheatmap para realizar heatmaps de análisis taxonómico 


```{r}
pheatmap(Phyla_matrix) # El objeto siempre debe de estar en formato de matriz y los valores como numéricos... en este salen clouster osea las lineas que ordenan entre grupos por asi decirlo
```

### _Notan algo en el orden de nuestras filas y columnas? Clusters_
La funcion default de pheatmap es que automaticamente te reacomoda (cluster) tus filas y columnas de acuerdo a como cree que estan mas relacionadas las variables; es decir las agrupa. Esta funcion suele ser util cuando haces heatmaps de genes ya que te permite ver como se activan o apagan en conjunto y si hay "clusters" de genes relacionados. Pero en nuestro caso arruino todo el pre-procesamiento previo que nosotros le dimos por lo que tenemos que quitarle ese default.

```{r}
pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE) # quitar clusters
```

### El siguiente problema? La escala 

Si se fijan los colores en este heatmap son cero utiles. Solo tenemos cambios graduales en una columna y el resto se ven todas horribles. Esto ocurre porque nuestros datos tienen mucha variacion entre ellos por lo que se puede arreglar de varias maneras y la funcion de pheatmap tiene el argumento de scala para tratar de solucionarlo. El default siempre es _none_ pero tambien se puede modificarlo por filas y columnas: 

```{r}
pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "none") # default

pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "column") # trasforma los valores usando de escala las muestras...osea las columnas...ESTE CASI NO LO VAMOS A USAR   

pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "row") # transforma los valor4es usando de escla los phylums...osea las filas... esta grafica esta bien solo se deberia cambiar la leyeda de la escala
```

Cual creen que es mas util? 

Desafortunadamente ninguno de ellos es muy util. El de columnas no hizo nada porque el problema recae en que tenemos phylums con muuucha abundancia y otros que casi estan llenos de ceros mientras; pero eso pasa en todas las muestras por lo que al tratar de escalarlo se ve asi. 

En el caso de la transformacion por filas nos va un poco mejor porque trata de normalizar las abundancias de todos los phylums a una escala. Sin embargo, por el mismo problema anterior lo unico que nos resalta es si alguna de las muestras tiene numeros extranamente altos o bajos DENTRO de ese mismo phylum. Es decir nos compara dentro de phylums pero no entre ellos. Asi que les voy a compartir el codigo que me tomo literalmente 1 semana encontrar y basicamente salvo mi tesis.

### _Como modificar la escala manualmente? breaks_

```{r}
## Funcion especificamente para separar nuestros datos en secciones 

quantile_breaks <- function(xs, n = 10) {
  breaks <- quantile(xs, probs = seq(0, 1, length.out = n))
  breaks[!duplicated(breaks)]
} # recordar que la funcion NUNCA se cambia de nombre (osea copiar y pegar siempre entre documentos igual)


mat_breaks <- quantile_breaks(Phyla_matrix, #la matriz
                              n = 10) # el default es 10 pero se puede poenr4 el numero de cortes que quiero en mis datos 
mat_breaks


pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "none", # regresamos a que nos ponga escala 
         breaks = mat_breaks) # aqui ponemos el objeto con cortes que creamos
```

### Por que no se ve bien los colores?

Aunque ya puede ver una mejora en nuestra escala el problema ahora es que la funcion no tiene la cantidad adecuada de colores para representar nuestros datos. Por ello nosotros le vamos a dar otros colores: 

```{r}
pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "none", # regresamos a que nos ponga escala 
         breaks = mat_breaks,
         color = colorRampPalette(c("snow2", "#B23AEE", "maroon1", "violetred4"))(9)) # este numero debe de ser mas pequeño que n de la funcion osea el n del met_break....el numero de de colores debe ser minimo 4 y es a como queremos nosotros osea donde se vea mas diferenciado 
```

### Mini ejercicio 

Cada quien va a poner un numero diferente en los breaks para que vean como cambiar el grafico. Recuerden a mas breaks mayor diferencias o cambios de color: 

```{r}
mat_breaks <- quantile_breaks(Phyla_matrix, #la matriz
                              n = 25) # el default es 10 pero se puede poenr4 el numero de cortes que quiero en mis datos 
mat_breaks


pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "none", # regresamos a que nos ponga escala 
         breaks = mat_breaks,
         color = colorRampPalette(c("snow2", "#00F5FF", "dodgerblue4", "#030303"))(21)) # este numero debe de ser mas pequeño que n de la funcion 



pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "none", # regresamos a que nos ponga escala 
         breaks = mat_breaks,
         color = colorRampPalette(c("snow2","lightskyblue1","plum3","magenta4","steelblue4","black"))(21)) # estos son los colores de la tesis de Isabel

# como conclusion es modificar los mat_breaks y luego el pheatmap
```

### _Los ultimos elementos de formato_

```{r}
# a partir de aqui va a ser diferente entre cada pheatmap
pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "none", # regresamos a que nos ponga escala
         color = colorRampPalette(c("snow2", "#00F5FF", "dodgerblue4", "#030303"))(21),
         breaks = mat_breaks,
         fontsize = 8, # tamaño de letra 
         gaps_col = c(2), #separacion entre columnas
         labels_col = c("Balox Salino", "Balox No Salino","Control Salino",
                        "Control No Salino"))
```

Otros posibles cambios que le podemos hacer a nuestro heatmap

* border_color: colores de las celdas 

* cellwidth / cellheight : ancho/alto de celda en puntos; si no se pone los valores depende del tamaño de la ventana

* clustering_distance_rows o columns: la distancia para clusterizar 

* clustering_method: metodos en hclust

* cutree_rows/cols: numero de clusters en el que los datos se van a dividir 

* treeheight_row/col: altura de los arboles de clusters defoult es 50 puntos 

* legend: true or false 

* legend_breaks: vector con los cortes de la leyenda (breaks es para si quieres colores en este caso colores de leyendas)

* legen_labels: vector con los nombres de los cortes para la leyenda

* annotation_row/col: filas de colores extra para demostrar los metadatos en el heatmap

* annotation_colors: colores manuales de las anotaciones 

* annotation_legend: true of false 

* annotation_names_row/col: true or false se veran los nombres de las anotaciones o no

* show_rownames/ colnames: true or false 

* main: titulo del grafico 

* fontsize_row/col: cambiar el tamaño de letra por separado 

* angle_col: angulo del texto. Solo se pueden elegir de estas opciones: (0, 45, 90, 270 and 315)

* display_numbers: true or false. Poner los valores en las celdas 

* number_format/color

* fontsize_number

* gaps_row/col: vector de donde poner los espacios en el heatmap

* filename: camino para guardar el heatmap como imagen

* width/height: en pulgadas 

* na_col: especificar el color de las celdas sin valor



### Mini ejercicio

Agregen o modifiquen 2 o mas de estos argumenos en su grafico 

```{r}
pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "none", # regresamos a que nos ponga escala
         color = colorRampPalette(c("snow2", "#00F5FF", "dodgerblue4", "#030303"))(21),
         breaks = mat_breaks,
         fontsize = 8, # tamaño de letra 
         gaps_col = c(2), #separacion entre columnas
         labels_col = c("Balox Salino", "Balox No Salino","Control Salino",
                        "Control No Salino"),
         border_color = "turquoise4",
         main = "Taxonomia en tratamientos",
         na_col = "#00FF00",
         fontsize_row = 6,
         fontsize_col = 8,
         angle_col = 0)
```


# Ejercicio final 

Usnado global patterns creen un heatmap de los phylums encontrados 

```{r}
data("GlobalPatterns")


Phyla_fun <- tax_glom(GlobalPatterns, taxrank = "Phylum", NArm = FALSE)

## Extraer datos del objeto phyloseq
OTU_matrix <- as.data.frame(Phyla_fun@otu_table)
Tax_matrix <- as.data.frame(Phyla_fun@tax_table)

# Renombramos las columnas de nuestras abundancias con el phylum de la tabla taxa
 


# no hacemos transpouse porque ya tenemos la tabla como filas y columnas como debe de ser en este caso no esta al reves, phylums en filas de de estar 
Phyla_matrix <- as.matrix(t(OTU_matrix)) # ESTO NO SE CORRE 


# PROCESAMIENTO DE DATOS 


Tax_matrix <- Tax_matrix[order(Tax_matrix[,1], #ese 1 corresponde a la primera columna y eso nos da en el codigo que todas las columnas se van a cambiar de mayor a menos 
                                   decreasing = TRUE),] # Ordenar de mayor a menor 

# ANALSIS TAXNONOMICO

pheatmap(Tax_matrix) # El objeto siempre debe de estar en formato de matriz y los valores como numéricos... en este salen clouster osea las lineas que ordenan entre grupos por asi decirlo


```

```{r}
# Phyla_matrix <- as.matrix(Phyla_matriz) para usar la funcion los datos siempre deben ser numericos o sea estar en una matriz 
```





```{r}

Phyla_fun <- tax_glom(GlobalPatterns, taxrank = "Phylum", NArm = FALSE)

## Extraer datos del objeto phyloseq

OTU_matrix <- as.data.frame(Phyla_fun@otu_table)
Tax_matrix <- as.data.frame(Phyla_fun@tax_table)

# Renombramos las columnas de nuestras abundancias con el phylum de la tabla taxa
Tax_matrix[54,2] <- "Unknown"
row.names(OTU_matrix) <- Tax_matrix$Phylum

# Crear matriz (afuerzas tenemos que trabajar con matrices, por eso creamos la matriz a partir de los OTUs)
Phyla_matrix <- as.matrix(OTU_matrix)

#class(Phyla_matirx) <- "numeric" para usr la funcion los datos siempre deben ser numerico o sea estar en una matriz 

```

# Procesamiento de datos 

Este proceso es específico para cada set de datos. Usualmente los heatmaps siempre van de mayor a menor, así que ese paso siempre se realiza, pero el resto consta de de ordenar las muestras y renombrar variables.

```{r}

Phyla_matrix <- Phyla_matrix[order(Phyla_matrix[,1], #ese 1 corresponde a la primera columna y eso nos da en el codigo que todas las columnas se van a cambiar de mayor a menos 
                                   decreasing = TRUE),] # Ordenar de mayor a menor 


```

## Usando el paquete Pheatmap para realizar heatmaps de análisis taxonómico 


```{r}
pheatmap(Phyla_matrix) # El objeto siempre debe de estar en formato de matriz y los valores como numéricos... en este salen clouster osea las lineas que ordenan entre grupos por asi decirlo
```


### _Notan algo en el orden de nuestras filas y columnas? Clusters_
La funcion default de pheatmap es que automaticamente te reacomoda (cluster) tus filas y columnas de acuerdo a como cree que estan mas relacionadas las variables; es decir las agrupa. Esta funcion suele ser util cuando haces heatmaps de genes ya que te permite ver como se activan o apagan en conjunto y si hay "clusters" de genes relacionados. Pero en nuestro caso arruino todo el pre-procesamiento previo que nosotros le dimos por lo que tenemos que quitarle ese default.

```{r}
pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE) # quitar clusters
```


### El siguiente problema? La escala 

Si se fijan los colores en este heatmap son cero utiles. Solo tenemos cambios graduales en una columna y el resto se ven todas horribles. Esto ocurre porque nuestros datos tienen mucha variacion entre ellos por lo que se puede arreglar de varias maneras y la funcion de pheatmap tiene el argumento de scala para tratar de solucionarlo. El default siempre es _none_ pero tambien se puede modificarlo por filas y columnas: 

```{r}
pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "none") # default

pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "row") # transforma los valores usando de escla los phylums...osea las filas... esta grafica esta bien solo se deberia cambiar la leyeda de la escala
```

### _Como modificar la escala manualmente? breaks_

```{r}
## Funcion especificamente para separar nuestros datos en secciones 

quantile_breaks <- function(xs, n = 10) {
  breaks <- quantile(xs, probs = seq(0, 1, length.out = n))
  breaks[!duplicated(breaks)]
} # recordar que la funcion NUNCA se cambia de nombre (osea copiar y pegar siempre entre documentos igual)


mat_breaks <- quantile_breaks(Phyla_matrix, #la matriz
                              n = 15) # el default es 10 pero se puede poner el numero de cortes que quiero en mis datos 
mat_breaks


pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "none", # regresamos a que nos ponga escala 
         breaks = mat_breaks) # aqui ponemos el objeto con cortes que creamos
```


### Por que no se ve bien los colores?

Aunque ya puede ver una mejora en nuestra escala el problema ahora es que la funcion no tiene la cantidad adecuada de colores para representar nuestros datos. Por ello nosotros le vamos a dar otros colores: 

```{r}
pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "none", # regresamos a que nos ponga escala 
         breaks = mat_breaks,
         color = colorRampPalette(c("snow2", "#B23AEE", "maroon1", "violetred4"))(10)) # este numero debe de ser mas pequeño que n de la funcion osea el n del met_break....el numero de de colores debe ser minimo 4 y es a como queremos nosotros osea donde se vea mas diferenciado 
```


### _Los ultimos elementos de formato_

```{r}
# a partir de aqui va a ser diferente entre cada pheatmap
pheatmap(Phyla_matrix,
         cluster_rows = FALSE, cluster_cols = FALSE,
         scale = "none", # regresamos a que nos ponga escala
         color = colorRampPalette(c("snow2", "#00F5FF", "dodgerblue4", "#030303"))(10),
         breaks = mat_breaks,
         fontsize = 8, # tamaño de letra 
         border_color = "turquoise4",
         main = "Phylums en GlobalPatterns",
         fontsize_row = 6,
         fontsize_col = 8,
         angle_col = 45)

```

## Graficos de barras

Se acuerdan que al ver las funciones que nos daba phyloseq vimos como hacer graficos de barras?, pues bueno ahora vamos a aprender a hacerlos bonitos: 

# Pre- procesamiento de datos 

```{r}
# Recuerden que este tipo de grafico siempre se hacen con abundancias relativas 

Psoil_rel <- transform_sample_counts(vid_bio, # objeto a transformar
                                     function(x) x/ sum(x)) # x es nu conteo

# otra vez juntar phylums
Top_phyla <- tax_glom(Psoil_rel, taxrank = "Phylum", NArm = FALSE)

# Seleccionar solo los valores top
Top_phyla <- prune_taxa(names(sort(taxa_sums(Top_phyla), TRUE)[1:10]), Top_phyla) # lo que esta en los corchetes es el top de lo que queremos usar osea el top 10 de mi muestra osea ordenar los nombres con las sumas con orden y solo agarrame los primeros 10 nombres 

```

### El grafrico

Usando la funcion plot_composition que viene del paquete microbiome
  CUANDO USAMOS GGPLOT TODO SE UNE CON + CUANDO USAMOS HEATMAP SE UNE CON ,

```{r}
# Grafico base 
plot_composition(Top_phyla, # objeto en valores relativos
                 plot.type = "barplot") #tipo de grafrico tambien hace heatmap

# Ahora mas bonito 
plot_composition(Top_phyla, plot.type = "barplot")+
                 theme_dark()+
                 scale_fill_brewer(palette = "Spectral", name = "Phylum",
                 labels = c("Actinobacteriota","Chloroflexi", "Proteobacteria", "Acidobacteriota", "Verrucomicrobiota", "Bacteroidota", "Cyanobacteria", "Patescibacteria", "Planctomycetota", "Firmicutes"))+ #poner los phylums
  guides(x= guide_axis(angle = 90))+
  scale_x_discrete(labels=c("Balox no Salino", "Control no Salino", "Control Salino", "Balox Salino"))
```

Si bien este grafico ya se ve bien, la forma mas comun de representar abundancia relativa es con porcentajes. Asi que les voy a enseñar la formula que scales te modifica esto facilmente:

```{r}
plot_composition(Top_phyla, plot.type = "barplot")+
                 theme_dark()+
                 scale_fill_brewer(palette = "Spectral", name = "Phylum",
                 labels = c("Actinobacteriota","Chloroflexi", "Proteobacteria", "Acidobacteriota", "Verrucomicrobiota", "Bacteroidota", "Cyanobacteria", "Patescibacteria", "Planctomycetota", "Firmicutes"))+ #poner los phylums
  guides(x= guide_axis(angle = 0))+
  scale_x_discrete(labels=c("Balox no Salino", "Control no Salino", "Control Salino", "Balox Salino"))+
  scale_y_continuous(breaks = pretty_breaks(n= 5), # num de separaciones (osea de 0 a 100%)
                     labels = scales::percent) # representadas en %
```

Usando estos dos grafricos que pueden confluir de sus datos? 
   Cyanobacteria: porque modifica los datos de balox salino, osea por diferencias
   Proteobacteria: tiene mas abundancia 

Si bien ya les enseñe a presentar graficos bonitos y definitivamente cualquiera de estos grafricos podrian incluirlo en un reporte, la visualizacion tambien nos permite darnos cuenta si existen ciertos patrones en abundancia. De esta manera seleccionar alguno de estes grupos y verlos en la lupa de una manera mas municiosa. 

Por ejemplo, yo de mis datos podria decir que dada la dominancia que tienen Ascomucota tal vez vale la pena revisarla municiosmente. Sin embargo, el heatmap no nos mostro si habian diferencais entre plantas o tratamientos (porque tal vez vale la pena revisarla minuciosamente). Sin embargo, el heatmap no nos mostro si habian diferencias entre plantas o tratamientos (porque tal vez no las hay?) por lo que hacer varios loops de analisis estadistico seria muy util para elegirlos

# Analizar estadisticamente a nivel de phylum

El ejemplo va a ser con ANOVA y por eso estamos usando los datos de ITS

Para los graficos ya habiamos extraido nuestras tablas de conteos y taxa, pero ahora tambien necesitamos nuestros metadatos:

# Pre pocesamiento de datos 
```{r}

Phyla_fun <- tax_glom(ITS_filtered, taxrank = "Phylum", NArm = FALSE)


# Extraemos datos del objeto 
OTU_matrix <- as.data.frame(Phyla_fun@otu_table)
Tax_matrix <- as.data.frame(Phyla_fun@tax_table)

# Extraer metadatos 
metadata <- as.data.frame(Phyla_fun@sam_data)

# Renombramos las columnas de nuestras abundancias con el phylun de la tabla de taxa 
colnames(OTU_matrix) <- Tax_matrix$Phylum 

# Join phyla with metadatos (unir los phylum con metadatos)
Fungi_phyla <- cbind(metadata,OTU_matrix)

```

# Normalizacion
```{r}
# Shapiro test
for (i in 5:ncol(Fungi_phyla)) {
  shapiro <- shapiro.test(Fungi_phyla[,i])
  normal <- ifelse(shapiro[["p.value"]]>0.05,"YES", "NO")
  print(c(i,normal))
}

# solo Ascomycota y Olpidiomycota normal 

### Normalize phyla

# transformacion Log
Norm_Fungi <- Fungi_phyla

for (i in 6:ncol(Norm_Fungi)) { #tambien puede ser 6:20 porque vamos de la 6 a la 20, de las 20 que son
  Norm_Fungi[,i] <- abs(log10(Norm_Fungi[,i]+1)) # abs es valor absoluto
}

# Volvemos a correr shapiro
for (i in 5:ncol(Norm_Fungi)) {
  shapiro <- shapiro.test(Norm_Fungi[,i])
  normal <- ifelse(shapiro[["p.value"]]>0.05,"YES", "NO")
  print(c(i,normal))
}

# Checamos grupos especificos
shapiro.test(Norm_Fungi$p__Mucoromycota) # 6
shapiro.test(Norm_Fungi$p__Basidiomycota) # 7
hist(Norm_Fungi$p__Mucoromycota)
hist(Norm_Fungi$p__Basidiomycota)

# Concluimos que casi todos nuestros phylums son normales 


# Tabla final solo para mis datos 
Norm_Fungi <- Norm_Fungi[,-c(5,13,15,18,19,20)] #estoy quitanto columnas, 5 y 13 eran normales, y el resto los quitamos por baja abundancia 

# Unir los datos (tablas)
Fungi_stats <- cbind(Fungi_phyla[,c(1:5,13)],Norm_Fungi[,5:14]) # seleccionamos las normales de Fungi phyla y lo unimos con los normalizados y metadatos, quitanto los que no se normalizaron

# tambien se puede hacer asi....
#Fungi_stats <- cbind(Fungi_phyla[,1:13],Norm_Fungi[,5:14])
#Fungi_stats <- Fungi_stats[,-c(6:12)] #quitamos las repetidas que estaban entre las 5 y 13

# osea necesitamos los datos normales y los transformados los datos no normalizados y que no se pueden transfomrar no se poenen y no nos interesan...

```

### ANOVA de dos vias (en este caso por la naturaleza de mis datos)

```{r}
### Prueba de homogeneidad 
# Test de Levene
for (i in 5:ncol(Fungi_stats)) {
  Lev_ex <- leveneTest(Fungi_stats[,i] ~ Plant_Type * Treatment,
                       data = Fungi_stats)
  levene <- ifelse(Lev_ex[["Pr(>F)"]]>0.05,"YES","NO")
  print(c(i,levene))
}

# todos pasan Levene

## For loop de ANOVA
#Paso 1: tabla vacia (sera especifica para sus datos)
phyla_pvalues <- data.frame(Plant = rep(NA,12),
                            Treatment = rep(NA,12),
                            P1_Trt = rep(NA,12)) # el num de variables
# osea; en la primera linea dice: me vas a repetir NA para las 12 variables que tengo sin contar los metadatos....el numero depende del numero de variables que tengas en tu tabla 
#lo mismo es para las otras 2 linea solo que con nombre distinto, en el primero se llama planta, en el segundo tratamiento y en el tercero planta con tratamiento 

for (i in 5:ncol(Fungi_stats)) {
  Phyla <- Fungi_stats[,i] # objeto de columna porque Anova no lee la columna
  AR <- Anova(aov(Phyla ~ Plant_Type * Treatment, #variables idep, tratamient
                  data = Fungi_stats)) # codigo de Anova en un objeto
  j <- i-4 # para que empieze a llenar desde la fila 1 osea i in 5, i-4 osea 1
  phyla_pvalues$Plant[j] <- AR$`Pr(>F)`[1]
  phyla_pvalues$Treatment[j] <- AR$`Pr(>F)`[2]
  phyla_pvalues$P1_Trt[j] <- AR$`Pr(>F)`[3]# en esta ocacion son 3 porque tenemos 3 tratamientos si tuvieramos 1 solo lo ponemos 1 vez
}
#### Elementos a cambiar cada que adapten este for loop 
# 1.- Fungi_stats por su tabla de datos 
# 2.- El numero despues de sus metadatos en este caso es el 5 
# 3.- Dentro de la Anova grupos, variables independientes o tratamientos (es lo mismo, llamado de diferente forma)
# 4.- j que es la formula general - x = 1 (i-x=1) cambia el valor de x que en este caso es 4 
# 5.- Nombres de phyla_pvalues dependera de sus datos y variables 

row.names(phyla_pvalues) <- colnames(Fungi_stats[5:16])

# Pueden guardar esta tabla 
write.csv(phyla_pvalues, "~/RStudio/CursoInnovak/Materiales/Fun_phyla_pvalue.csv")

```

Basados en estos resultados nosotros podemos elegir cual de estos phylums se puede ver en a un nivel mas bajo. Asi mismo no tenemos que sacar tukey para todos solo para los significativos: 

```{r}
## Mucoromycota, Chytridiomycota y Zoopagomycota

TukeyHSD(aov(p__Zoopagomycota ~ Plant_Type * Treatment,
             data = Fungi_stats))
TukeyHSD(aov(p__Mucoromycota ~ Plant_Type * Treatment,
             data = Fungi_stats))
TukeyHSD(aov(p__Chytridiomycota ~ Plant_Type * Treatment,
             data = Fungi_stats))

# es un ejemplo de como se haria 
```

El siguiente paso sería graficar algunas de estas relaciones interesantes 

## Ejercicio usando t.test:

Este ejercicio lo haremos juntos. Si bien podria haberles dado el codigo, quise que vieramos juntos esta vez como se podria adaptar un codigo que ya sabemos (en este caso el for loop de ANOVA) a un caso que no sabemos (T test).
Si recuerdan los datos de vid no podemos analizarlos por ANOVA proque solo tenemos una variable de cada "grupo". Sin embargo al hacer diversidad alfa vimos que si juntamos los datos podemos hacer t test. En este caso tenemos muchos datos (mas que solo los 7 indicies de diversidad alfa) por lo que hace4rlo uno por uno seria una tarea ridicula asi que vamos a hacer el analisis usando un for loop: 

```{r}

Phyla_fun <- tax_glom(vid_bio, taxrank = "Phylum", NArm = FALSE)

# Extraemos datos del objeto 
OTU_matrix <- as.data.frame(Phyla_fun@otu_table)
Tax_matrix <- as.data.frame(Phyla_fun@tax_table)

# Extraer metadatos 
metadata <- as.data.frame(Phyla_fun@sam_data)

# Renombramos las columnas de nuestras abundancias con el phylun de la tabla de taxa 
colnames(OTU_matrix) <- Tax_matrix$Phylum 
OTU_matrix <- OTU_matrix[,-c(10,21)]

# Join phyla with metadatos (unir los phylum con metadatos)
vid_phyla <- cbind(metadata,OTU_matrix)

## Checar normalidad de los datos 
#Shapiro en for loop
for (i in 3:ncol(vid_phyla)) {
  shapiro <- shapiro.test(vid_phyla[,i])
  normal <- ifelse(shapiro[["p.value"]]>0.05,"YES", "NO")
  print(c(i,normal))
}

# vamos a quitar el 10, 15, 27 y del 38:40 por baja abundancia, no los vamos a tratar de normalizar 

## Seleccionamos tabla  
Norm_vid <- vid_phyla[,c(24:26,28,30:34,37)]

# Normalizamos 
for (i in 1:ncol(Norm_vid)) { #tambien puede ser 6:20 porque vamos de la 6 a la 20, de las 20 que son
  Norm_vid[,i] <- abs(log10(Norm_vid[,i]+1)) # abs es valor absoluto
}

# Volvemos a correr shapiro 
for (i in 1:ncol(Norm_vid)) {
  shapiro <- shapiro.test(Norm_vid[,i])
  normal <- ifelse(shapiro[["p.value"]]>0.05,"YES", "NO")
  print(c(i,normal))
}


# Juntar para tabla 
vid_stats <- cbind(vid_phyla[,-c(10,15,24:28,30:34,37:40)],Norm_vid) # contando las que eliminamos tendriamos que tener 34 variables
# si le ponemos cbind las une horizontalmente si le ponemos rcbind los une verticalmente 

### For loop de t.test
# paso 1.- tabla vacia 
phyla_pvalues <- data.frame(Tratamiento = rep(NA,32),
                            Suelo = rep(NA,32))
# vamos a hace4r dos t.test uno para cada variable por eso dos columnas 
                            
# paso 1.5.- ver si se pueden meter valores por columna 
objeto_T <- t.test(Proteobacteria ~ Tratamiento, data = vid_stats)
# aqui vimos como llamar al p.value = objeto_T[["p.value"]]
#otra manera de ver si se puede es asi: 
#t.test(vid_stats[,3] ~ Tratmiento, data= vid_stats)

# paso 2.- for loop
for (i in 3:ncol(vid_stats)) {
  T_trat <- t.test(vid_stats[,i] ~ Tratamiento, data = vid_stats)
  S_trat <- t.test(vid_stats[,i] ~ Suelo, data = vid_stats)
  j <- i-2 # para que empiece a llenar desde la fila 1 osea i in 3, i-2 osea 1
  phyla_pvalues$Tratamiento[j] <- T_trat[["p.value"]]
  phyla_pvalues$Suelo[j] <- S_trat[["p.value"]]# en esta ocacion son 2 porque tenemos 2 tratamientos, depende de los tratamientos que tenemos
}

# paso 3.- poner los nombres 
row.names(phyla_pvalues) <- colnames(vid_stats[3:34])

# paso 4.- guardar tabla 
write.csv(phyla_pvalues, "~/RStudio/CursoInnovak/Materiales/vid_pvalue.csv")

```

# conclusion de analisis a nivel phylum 

Despues de todos estos graficos y analisis estadisticos ustedes deberan tener unos 5 phylums tops que quieran analizar mas a profundiad. En mi caso me voy a enfocar en Ascomycosa y Mucoromycota

EN EL CASO DE VID, habiamos dicho que:
* Cyanobacteria, Proteobacteria basados en graficos
* Chloroflexi y Actinobacteria basados en estadistica

```{r}
Proteo <- subset_taxa(vid_bio, Phylum == "Proteobacteria")

```

# VISUALIZAR A NIVEL DE ORDEN 

Si bien despues de phyum viene clase, por razones de tiempo (tanto de la clase como de su trabajo) les recomiendo que el siguiente nivel a analizar sea orden: 

```{r}
Proteo_or <- tax_glom(Proteo,taxrank = "Order", NArm = FALSE) # juntar orden
```

En este caso no lo hice para Mucoromycota tambien porque si se fijan solo tiene un orden. Aglomerar todos nuestros datos por orden no nos serviria de nada por lo que les vuelvo a reiterar que aqui depende de cada caso para que sigan su flujo de analisis. A partir de aqui yo tendria 2 opciones: 

1. Si se fijan a nivel de familias si habian varias clasificaciones por lo que podria analizar a ese nivel en vez de a nivel de orden o

2. Pasarme directamente al siguiente nivel de analisis: el genero

Nuevamente al ver los datos (sin graficar) me doy cuenta que las familias y los generos siguen los mismos patrones por lo que en vez de analizar 2 veces dejaremos Mucoromycota para el siguiente nivel.

### Heatmap o barplot?

Primero vamos a ver el barplot default sin arreglar nada en los datos:

```{r}
plot_composition(Proteo_or,plot.type = "barplot")+
  theme_bw() 
# me enfocare en el mas abundante que es el MIXK01255P 
```

Anteriormente les habia dicho que la funcion plot_composition de microbiome tiene tambien una opcion de heatmap. El problema es que es mucho mas tardada de correr y los graficos no quedan tan bien. La otra opcion es la de phyloseq que aunque corre mejor en mi opinion no es tan sensible a cambios como pheatmap. 

sin embargo, en este caso no vamos a pasar por todo el proceso de extraer tablas y hacer un "buen" heatmap por una simple razon: A pesr de que si nos estamos tomando el tiempo de analizar orden yo lo veo mas como un nivel de transicion. Es decir, nos ayuda a dirigir nuestro analisis a el o los generos que podrian llegar a ser interesantes asi que les voy a enseñar dos opciones de heatmap rapidas pero feas: 

```{r}

# Heatmap con microbiome
plot_composition(Proteo_or, plot.type = "heatmap")+
  theme_bw()+
  coord_flip()+
  theme(axis.text = element_text(size = 6))
# JIQUR4617P
# este tipo de heatmap osea el de microbiome tarda mas en correr

# Usando la funcion de phyloseq
plot_heatmap(Proteo_or, 
             low = "#40E0D0", high = "deeppink3",
             na.value = "lightyellow",
             taxa.order = names(sort(taxa_sums(Proteo_or))))
```
Los graficos a nivel de orden son exploratorios y por lo mismo decidi solo mostrarles como se verian con funciones basicas. 

Aunque en mi caso es trampa (porque yo ya se como se cojmportan mis datos), de ambos graficos yo podria concluir que el orden de mayor interes es Hypocreales ya que tiene mucha mas abundancia que el resto. Sin embargo si no ven un patron exacto o hay mucha variacion en sus datos si podrian meter sus datos en uno de los for loop que ya hemos creado. 

Concluisiones de vid a nivel de orden: 

1.- Chloroflexi: por diferencias 
*Thermomicrobiales
*Chloroflexales
*SBR-1031
Por analisis estadistico seria: 
*Thermomicrobiales
*SBR-1031

2.- Proteobacteria: por abundancia 
*Rhizobiales
Por analisis estadistico seria:
*Sphingomonadales
*Caulobacteriales

3.- Actinobacteria: casi uniforme
*Micromonosporales (por abundancia)
*Propionibacteriales (diferencia minima)
*Micrococcales (diferencia minima)
*Streptomycetales (diferencia minima)
Por analisis estadistico seria:
*Corynebacteriales

4.- Cyanobacteria: por abundancia 
*Chloroplast
Por analisis estadistico no hay diferencias 


### Ejercicio: Analisis estadistico 

Usando sus datos de vid pasen los valores de orden para determinar el camino de analisis adaptando los for loops de t.test que creamos para phylum

```{r}
Phyla_fun <- tax_glom(vid_bio, taxrank = "Phylum", NArm = FALSE) # este paso ya no lo corro ni hago porque ya lo hicimos anteriormente, entonces empezamos por extraer los datos 

# Extraemos datos del objeto 
OTU_matrix <- as.data.frame(Proteo_or@otu_table)
Tax_matrix <- as.data.frame(Proteo_or@tax_table)

# Extraer metadatos 
metadata <- as.data.frame(Proteo_or@sam_data)

# Renombramos las columnas de nuestras abundancias con el phylun de la tabla de taxa 
colnames(OTU_matrix) <- Tax_matrix$Order # cambiamos de phylum a order 


# Join phyla with metadatos (unir los phylum con metadatos)
vid_phyla <- cbind(metadata,OTU_matrix)

## Checar normalidad de los datos 
#Shapiro en for loop
for (i in 3:ncol(vid_phyla)) {
  shapiro <- shapiro.test(vid_phyla[,i])
  normal <- ifelse(shapiro[["p.value"]]>0.05,"YES", "NO")
  print(c(i,normal))
}
# vamos a quitar el 8, 10:11, 15, 21:22, 27:31, 33:34, 36, 38, 40 y del 42:45 

####### NOS VAMOS A SALTAR ESTA PARTE PARA AHORRAR TIEMPO POR LO TANTO NO VAMOS A NORMALIZAR LOS DATOS 
## Seleccionamos tabla  
Norm_vid <- vid_phyla[,c(24:26,28,30:34,37)]
# Normalizamos 
for (i in 1:ncol(Norm_vid)) { #tambien puede ser 6:20 porque vamos de la 6 a la 20, de las 20 que son
  Norm_vid[,i] <- abs(log10(Norm_vid[,i]+1)) # abs es valor absoluto
}
# Volvemos a correr shapiro 
for (i in 1:ncol(Norm_vid)) {
  shapiro <- shapiro.test(Norm_vid[,i])
  normal <- ifelse(shapiro[["p.value"]]>0.05,"YES", "NO")
  print(c(i,normal))
}
# Juntar para tabla 
vid_stats <- cbind(vid_phyla[,-c(10,15,24:28,30:34,37:40)],Norm_vid) # contando las que eliminamos tendriamos que tener 34 variables
# si le ponemos cbind las une horizontalmente si le ponemos rcbind los une verticalmente 


##### PROSGUIMOS AQUI PARA AHORRAR TIEMPO
### For loop de t.test
# paso 1.- tabla vacia 
phyla_pvalues <- data.frame(Tratamiento = rep(NA,43),
                            Suelo = rep(NA,43)) # este numero es el numero de datos que tenga quitanto los metadatos osea en este caso tratamiento y suelo osea de 45 -2 son 43
# vamos a hacer dos t.test uno para cada variable por eso dos columnas 

# este paso LO SALTAMOS                            
# paso 1.5.- ver si se pueden meter valores por columna 
objeto_T <- t.test(Proteobacteria ~ Tratamiento, data = vid_stats)
# aqui vimos como llamar al p.value = objeto_T[["p.value"]]
#otra manera de ver si se puede es asi: 
#t.test(vid_stats[,3] ~ Tratmiento, data= vid_stats)

# paso 2.- for loop
for (i in 3:ncol(vid_phyla)) {
  T_trat <- t.test(vid_phyla[,i] ~ Tratamiento, data = vid_phyla)
  S_trat <- t.test(vid_phyla[,i] ~ Suelo, data = vid_phyla)
  j <- i-2 # para que empiece a llenar desde la fila 1 osea i in 3, i-2 osea 1
  phyla_pvalues$Tratamiento[j] <- T_trat[["p.value"]]
  phyla_pvalues$Suelo[j] <- S_trat[["p.value"]]# en esta ocacion son 2 porque tenemos 2 tratamientos, depende de los tratamientos que tenemos
}

# paso 3.- poner los nombres 
row.names(phyla_pvalues) <- c("Reyranellales","Rhizobiales","U1","U2","Holosporales","Paracaedibacterales","Elsterales","Defluviicoccales","Puniceispirillales","Nitrococcales","Tistrellales","Micavibrionales","Zavarziniales","Sphingomonadales","Caulobacterales","Pseudomonadales","Rickettsiales","Thalassobaculales","Parvibaculales","Rhodobacterales","Dongiales","Micropepsales","Acetobacterales","Azospirillales","PLTA13","Burkholderiales","Legionellales","Coxiellales","Gammaproteobacteria Incertae Sedis","Steroidobacterales","R7C24","Xanthomonadales","Kiloniellales","JG36-TzT-191","U3","CCD24","Diplorickettsiales","Ferrovibrionales","Enterobacterales","HOC36","Nitrosococcales","B108","Beggiatoales")

# paso 4.- guardar tabla 
write.csv(phyla_pvalues, "~/RStudio/CursoInnovak/Materiales/vid_pvalue_or.csv")
```


# VISUALIZACION A NIVEL DE GENERO/ESPECIE

Dentro del orden u ordenes que eleigieron se puede seguir el proceso de flitrado y aglomeracion anterior para ir eligiendo un genero (en el caso de bacterias) o algunas especies en el caso de hongos (para analisis).

Si bien a mi como ecologa de suelo se me hace interesante ver si realmente hay esta clase de cambios a niveles mas bajos y luego como estos se traducen a cambios funcionales a estas alturas su reporte va a ser del largo de mi tesis. Por ello en esta seccion solo nos vamos a enfocar en ciertos generos y especies que son importantes reportar ya que son conocidos por su importancia tanto buena como mala.

A menos que les pidan un analisis super minucioso, yo les recomiendo que hagan el analisis de phylum para darse una idea global de los datos y de ahi se enfoquen en las siguientes especies como marcadores de salud de suelo:

__Bacterias:__

* Pseudomonas

* Rhizobium

* Rubrobacter (opcional)

* Rhizobacter

* Clavibacter

__Hongos:__

* Trichoderma           

* Glomus

* Fusarium

* Apophysomyces 

En mi caso solo veremos los graficos de Fusarium y Apophysomyces


```{r}
Baci <- subset_taxa(vid_bio, Genus == "Bacillus")
```

Si bien a nivel de genero (es decir con bacterias) ustedes juntarian todos los conteos de dicho genero graficaran y verian si vale la pena o no hacer el analisis estadistico. 

En el caso de hongos (es decir el ejemplo a continuacion) primero tengo que juntar por especie ya que la mayoria fueron identificadas. De ahi loq ue yo hice fue repetir os for loops de analisis estadistico para ver si alguna o todas las especies mostraban diferentes estadisticas. Este proceso es un poco mas tardado pero ya tenemos todas las herramientas para hacerlo. 

## Pre-procesamiento de datos

```{r}
###### ESTO NO LO CORREMOS PERO EL CODIGO ES EL QUE HIZO ISA CON SUS DATOS DE HONGOS; solo para saber como se puede sacar las especies de los hongos. 

Fusarium <- tax_glom(Fusa, taxrank = "Species", NArm = FALSE)

## Extract matrix 
OTU_matrix <- as.data.frame(Fusarium@otu_table)
Tax_matrix <- as.data.frame(Fusarium@tax_table)

## Rename columns from otu_matriz with phylum from tax_matrix
colnames(OTU_matriz) <- Tax_matrix$Species

## Extract metadata
metadata <- as.data.frame(Fusarium@sam_data)

## Join phyla with metadada 
Fusarium <- cbind(metadata, OTU_matrix)

## Suma total de Bacillus
Sum_fus <- rowSums(Fusarium[,5:14])
Sum_fus <- cbind(metadata,Sum_fus)

# Shapiro test 
shapiro.test(Sum_fus ~ Plant_Type * Treatment,
             data = Sum_fus) # passed 

# ANOVA
Anova(aov(Sum_fus ~ Plant_Type * Treatment,
          data = Sum_fus)) # no significativo 
```


## Especies especificas

Despues de hacer el analisis anterior para cada una de las especies descubir 2 cosas _F.tricinctum_ mostraba diferencias estadisticas entre tipos de planta (que o se los voy a mostrar) mientras que _F. verticilloides_ mostraba diferencia entre tratamiento: 

```{r}
ggplot(Fusarium, aes(x = Treatment, y= s_verticillioides, col = Plant_Type))+
  geom_boxplot(fill= "snow2", lwd= 0.7)+
  theme_bw(base_size = 15)+
  scale_color_manual(name = "Plant Type",
                     values = c("steelblue", "lightpink", "burlywood3"))+
  xlab("Treatment") + ylab("Abundance") +
  geom_signif(y_position = 800, xmin = 0.6, xmax = 3.4,
              annnotation = "A", tip_length = 0.01,
              col = 1) +
  geom_signif(y_position = 1100, xmin = 3.6, xmax = 4.4,
              annotation = "B", tip_length = 0.01,
              col = 1) #### seguimos sin correr este es de ISA
```


### Ejercicio 

Graficar su genero en especifico 

```{r}
# Pre-procesamiento de datos 
# ya tenemos nuestro camino/ objeto arriba llamado Baci....

## Extract matrix 
OTU_matrix <- as.data.frame(Baci@otu_table)
## Extract metadata
metadata <- as.data.frame(Baci@sam_data)

Bacillus <- cbind(metadata,OTU_matrix)

# Opcion 1 para grafico de barras 
Sum_bac <- rowSums(Bacillus[,3:43])
Sum_bacillus <- cbind(metadata,Sum_bac)

# esta funcion es para boxplot
Bacillus_m <- reshape2::melt(Bacillus)


# grafico
ggplot(Bacillus_m, aes(x = Tratamiento, y= value, col = Suelo))+
  geom_boxplot(fill= "snow2", lwd= 0.5)+
  theme_bw(base_size = 12)+
  scale_color_manual(name = "Suelo",
                     values = c("steelblue", "lightpink"))+
  xlab("Tratamiento") + ylab("Value")

# en este caso a nivel estadistico no hay diferencias...
```

Conclusiones de analisis taxnonomico 

Como pueden ver el analisis taxonomico es muy exploratorio, se pueden tardar 1 hora o una semana dependiendo el nivel de profundidad que le quieran dar. De cajon les recomiendo que chequen phylum y a nivel de genero analizar los grupos que les mostre para todos sus reportes. Muchas veces el analisis a nivel taxonomicos altos los puede llevar a analizar otros generos que tambien son de relevancia agricola pero como pueden ver ir de gran a pequeña escala es un proceso un poco tardado aunque no es dificil. La ventaja de que lo hagan entre todos es que cada quien pueda tomar un taxon diferente y analizarlos por separado. 



